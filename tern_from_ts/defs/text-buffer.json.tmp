{
  "TextBuffer": {
    "IPointStatic": {
      "fromObject": "fn(point: IPoint, copy?: bool) -> IPoint",
      "min": "fn(point1: IPoint, point2: IPoint) -> IPoint"
    },
    "IPoint": {
      "row": "number",
      "column": "number",
      "copy": "fn() -> IPoint",
      "freeze": "fn() -> IPoint",
      "translate": "fn(delta: IPoint) -> IPoint",
      "add": "fn(other: IPoint) -> IPoint",
      "splitAt": "fn(column: number) -> [IPoint]",
      "compare": "fn(other: IPoint) -> number",
      "isEqual": "fn(other: IPoint) -> bool",
      "isLessThan": "fn(other: IPoint) -> bool",
      "isLessThanOrEqual": "fn(other: IPoint) -> bool",
      "isGreaterThan": "fn(other: IPoint) -> bool",
      "isGreaterThanOrEqual": "fn(other: IPoint) -> bool",
      "toArray": "fn() -> [number]",
      "serialize": "fn() -> [number]"
    },
    "IRangeStatic": {
      "deserialize": "fn(array: [IPoint]) -> IRange",
      "fromObject": "fn(object: [IPoint]) -> IRange",
      "fromText": "fn(point: IPoint, text: string) -> IRange",
      "fromPointWithDelta": "fn(startPoint: IPoint, rowDelta: number, columnDelta: number) -> IRange"
    },
    "IRange": {
      "start": "IPoint",
      "end": "IPoint",
      "serialize": "fn() -> [[number]]",
      "copy": "fn() -> IRange",
      "freeze": "fn() -> IRange",
      "isEqual": "fn(other: IRange) -> bool",
      "compare": "fn(object: [IPoint]) -> number",
      "isSingleLine": "fn() -> bool",
      "coversSameRows": "fn(other: IRange) -> bool",
      "add": "fn(object: [IPoint]) -> IRange",
      "translate": "fn(startPoint: IPoint, endPoint: IPoint) -> IRange",
      "intersectsWith": "fn(otherRange: IRange) -> bool",
      "containsRange": "fn(otherRange: IRange, exclusive: bool) -> bool",
      "containsPoint": "fn(point: IPoint, exclusive: bool) -> bool",
      "intersectsRow": "fn(row: number) -> bool",
      "intersectsRowRange": "fn(startRow: number, endRow: number) -> bool",
      "union": "fn(otherRange: IRange) -> IRange",
      "isEmpty": "fn() -> bool",
      "toDelta": "fn() -> IPoint",
      "getRowCount": "fn() -> number",
      "getRows": "fn() -> [number]"
    },
    "IHistory": {},
    "IMarkerManager": {},
    "IMarker": {},
    "IBufferPatch": {},
    "ITextBufferStatic": {
      "Point": "IPointStatic",
      "Range": "IRangeStatic",
      "newlineRegex": "?"
    },
    "ITextBuffer": {
      "cachedText": "string",
      "stoppedChangingDelay": "number",
      "stoppedChangingTimeout": "?",
      "cachedDiskContents": "string",
      "conflict": "bool",
      "file": "?",
      "refcount": "number",
      "lines": "[string]",
      "lineEndings": "[string]",
      "offsetIndex": "?",
      "history": "IHistory",
      "markers": "IMarkerManager",
      "loaded": "bool",
      "digestWhenLastPersisted": "string",
      "modifiedWhenLastPersisted": "bool",
      "useSerializedText": "bool",
      "deserializeParams": "fn(params: ?) -> ?",
      "serializeParams": "fn() -> ?",
      "getText": "fn() -> string",
      "getLines": "fn() -> string",
      "isEmpty": "fn() -> bool",
      "getLineCount": "fn() -> number",
      "getLastRow": "fn() -> number",
      "lineForRow": "fn(row: number) -> string",
      "getLastLine": "fn() -> string",
      "lineEndingForRow": "fn(row: number) -> string",
      "lineLengthForRow": "fn(row: number) -> number",
      "setText": "fn(text: string) -> IRange",
      "setTextViaDiff": "fn(text: ?) -> [?]",
      "setTextInRange": "fn(range: IRange, text: string, normalizeLineEndings?: bool) -> IRange",
      "insert": "fn(position: IPoint, text: string, normalizeLineEndings?: bool) -> IRange",
      "append": "fn(text: string, normalizeLineEndings?: bool) -> IRange",
      "delete": "fn(range: IRange) -> IRange",
      "deleteRow": "fn(row: number) -> IRange",
      "deleteRows": "fn(startRow: number, endRow: number) -> IRange",
      "buildPatch": "fn(oldRange: IRange, newText: string, normalizeLineEndings?: bool) -> IBufferPatch",
      "applyPatch": "fn(patch: IBufferPatch) -> ?",
      "getTextInRange": "fn(range: IRange) -> string",
      "clipRange": "fn(range: IRange) -> IRange",
      "clipPosition": "fn(position: IPoint) -> IPoint",
      "getFirstPosition": "fn() -> IPoint",
      "getEndPosition": "fn() -> IPoint",
      "getRange": "fn() -> IRange",
      "rangeForRow": "fn(row: number, includeNewline?: bool) -> IRange",
      "characterIndexForPosition": "fn(position: IPoint) -> number",
      "positionForCharacterIndex": "fn(offset: number) -> IPoint",
      "getMaxCharacterIndex": "fn() -> number",
      "loadSync": "fn() -> ITextBuffer",
      "load": "fn() -> ?",
      "finishLoading": "fn() -> ITextBuffer",
      "handleTextChange": "fn(event: ?) -> ?",
      "destroy": "fn() -> ?",
      "isAlive": "fn() -> bool",
      "isDestroyed": "fn() -> bool",
      "isRetained": "fn() -> bool",
      "retain": "fn() -> ITextBuffer",
      "release": "fn() -> ITextBuffer",
      "subscribeToFile": "fn() -> ?",
      "hasMultipleEditors": "fn() -> bool",
      "reload": "fn() -> ?",
      "updateCachedDiskContentsSync": "fn() -> string",
      "updateCachedDiskContents": "fn() -> ?",
      "getBaseName": "fn() -> string",
      "getPath": "fn() -> string",
      "getUri": "fn() -> string",
      "setPath": "fn(filePath: string) -> ?",
      "save": "fn()",
      "saveAs": "fn(filePath: string) -> ?",
      "isModified": "fn() -> bool",
      "isInConflict": "fn() -> bool",
      "destroyMarker": "fn(id: ?) -> ?",
      "matchesInCharacterRange": "fn(regex: ?, startIndex: ?, endIndex: ?) -> [?]",
      "scan": "fn(regex: ?, iterator: ?) -> ?",
      "backwardsScan": "fn(regex: ?, iterator: ?) -> ?",
      "replace": "fn(regex: ?, replacementText: ?) -> ?",
      "scanInRange": "fn(regex: ?, range: ?, iterator: ?, reverse: ?) -> ?",
      "backwardsScanInRange": "fn(regex: ?, range: ?, iterator: ?) -> ?",
      "isRowBlank": "fn(row: number) -> bool",
      "previousNonBlankRow": "fn(startRow: number) -> number",
      "nextNonBlankRow": "fn(startRow: number) -> number",
      "usesSoftTabs": "fn() -> bool",
      "cancelStoppedChangingTimeout": "fn() -> ?",
      "scheduleModifiedEvents": "fn() -> ?",
      "emitModifiedStatusChanged": "fn(modifiedStatus: ?) -> ?",
      "logLines": "fn(start: number, end: number)",
      "undo": "fn() -> ?",
      "redo": "fn() -> ?",
      "transact": "fn(fn: Function) -> ?",
      "beginTransaction": "fn() -> ?",
      "commitTransaction": "fn() -> ?",
      "abortTransaction": "fn() -> ?",
      "clearUndoStack": "fn() -> ?",
      "markRange": "fn(range: ?, properties: ?) -> ?",
      "markPosition": "fn(range: ?, properties: ?) -> ?",
      "getMarker": "fn(id: number) -> IMarker",
      "getMarkers": "fn() -> [IMarker]",
      "getMarkerCount": "fn() -> number"
    }
  },
  "text-buffer": "_",
  "!name": "text-buffer.d.ts"
}
