{
  "linq": {
    "EnumerableStatic": {
      "Choice": "fn(contents: [T]) -> ?",
      "Cycle": "fn(contents: [T]) -> ?",
      "Empty": "fn() -> ?",
      "From": "fn(obj: [T]) -> ?",
      "Return": "fn(element: T) -> ?",
      "Matches": "fn(input: string, pattern: RegExp) -> ?",
      "Range": "fn(start: number, count: number, step?: number) -> ?",
      "RangeDown": "fn(start: number, count: number, step?: number) -> ?",
      "RangeTo": "fn(start: number, to: number, step?: number) -> ?",
      "Repeat": "fn(obj: ?, count?: number) -> ?",
      "RepeatWithFinalize": "fn(initializer: fn(), finalizer: fn(resource: T)) -> ?",
      "Generate": "fn(func: fn(), count?: number) -> ?",
      "ToInfinity": "fn(start?: number, step?: number) -> ?",
      "ToNegativeInfinity": "fn(start?: number, step?: number) -> ?",
      "Unfold": "fn(seed: ?, func: fn($: ?)) -> ?"
    },
    "Enumerable": {
      "CascadeBreadthFirst": "fn(func: fn($: ?), resultSelector: fn(v: ?, i: number)) -> ?",
      "CascadeDepthFirst": "fn(func: fn($: ?), resultSelector: fn(v: ?, i: number)) -> ?",
      "Flatten": "fn(items: [?]) -> ?",
      "Pairwise": "fn(selector: fn(prev: ?, next: ?)) -> ?",
      "Scan": "fn(func: fn(a: ?, b: ?)) -> ?",
      "Select": "fn(selector: fn($: T, i: number)) -> ?",
      "SelectMany": "fn(collectionSelector: fn($: ?, i: number), resultSelector?: fn($: ?, item: ?)) -> ?",
      "Where": "fn(predicate: fn($: T, i: number)) -> ?",
      "OfType": "fn(type: Function) -> ?",
      "Zip": "fn(second: [?], selector: fn(v1: ?, v2: ?, i: number)) -> ?",
      "Join": "fn(inner: [?], outerKeySelector: fn(v1: ?), innerKeySelector: fn(v1: ?), resultSelector: fn(v1: ?, v2: ?), compareSelector?: fn(v: ?)) -> ?",
      "GroupJoin": "fn(inner: [?], outerKeySelector: fn(v1: ?), innerKeySelector: fn(v1: ?), resultSelector: fn(v1: ?, v2: ?), compareSelector?: fn(v: ?)) -> ?",
      "All": "fn(predicate: fn($: T)) -> bool",
      "Any": "fn(predicate?: fn($: T)) -> bool",
      "Concat": "fn(second: [?]) -> ?",
      "Insert": "fn(index: number, second: [?]) -> ?",
      "Alternate": "fn(value: ?) -> ?",
      "Contains": "fn(value: ?, compareSelector?: fn($: ?)) -> bool",
      "DefaultIfEmpty": "fn(defaultValue: ?) -> ?",
      "Distinct": "fn(compareSelector?: fn($: ?)) -> ?",
      "Except": "fn(second: [?], compareSelector?: fn($: ?)) -> ?",
      "Intersect": "fn(second: [?], compareSelector?: fn($: ?)) -> ?",
      "SequenceEqual": "fn(second: [?], compareSelector?: fn($: ?)) -> bool",
      "Union": "fn(second: [?], compareSelector?: fn($: ?)) -> ?",
      "OrderBy": "fn(keySelector?: fn($: T)) -> ?",
      "OrderByDescending": "fn(keySelector?: fn($: ?)) -> ?",
      "Reverse": "fn() -> ?",
      "Shuffle": "fn() -> ?",
      "GroupBy": "fn(keySelector: fn($: ?), elementSelector?: fn($: ?), resultSelector?: fn(key: ?, e: ?), compareSelector?: fn($: ?)) -> ?",
      "PartitionBy": "fn(keySelector: fn($: ?), elementSelector?: fn($: ?), resultSelector?: fn(key: ?, e: ?), compareSelector?: fn($: ?)) -> ?",
      "BufferWithCount": "fn(count: number) -> ?",
      "Aggregate": "fn(func: fn(a: ?, b: ?))",
      "Average": "fn(selector?: fn($: ?)) -> number",
      "Count": "fn(predicate?: fn($: ?)) -> number",
      "Max": "fn(selector?: fn($: T)) -> ?",
      "Min": "fn(selector?: fn($: T)) -> ?",
      "MaxBy": "fn(selector: fn($: T)) -> ?",
      "MinBy": "fn(selector: fn($: T)) -> Date",
      "Sum": "fn(selector?: fn($: ?)) -> number",
      "ElementAt": "fn(index: number) -> T",
      "ElementAtOrDefault": "fn(index: number, defaultValue: T) -> T",
      "First": "fn(predicate?: fn($: T)) -> T",
      "FirstOrDefault": "fn(defaultValue: T, predicate?: fn($: T)) -> T",
      "Last": "fn(predicate?: fn($: T)) -> T",
      "LastOrDefault": "fn(defaultValue: T, predicate?: fn($: T)) -> T",
      "Single": "fn(predicate?: fn($: T)) -> T",
      "SingleOrDefault": "fn(defaultValue: T, predicate?: fn($: T)) -> T",
      "Skip": "fn(count: number) -> ?",
      "SkipWhile": "fn(predicate: fn($: T, i: number)) -> ?",
      "Take": "fn(count: number) -> ?",
      "TakeWhile": "fn(predicate: fn($: T, i: number)) -> ?",
      "TakeExceptLast": "fn(count?: number) -> ?",
      "TakeFromLast": "fn(count: number) -> ?",
      "IndexOf": "fn(item: ?) -> number",
      "LastIndexOf": "fn(item: ?) -> number",
      "ToArray": "fn() -> [T]",
      "ToLookup": "fn(keySelector: fn($: ?), elementSelector?: fn($: ?), compareSelector?: fn(key: ?)) -> ?",
      "ToObject": "fn(keySelector: fn($: ?), elementSelector: fn($: ?)) -> ?",
      "ToDictionary": "fn(keySelector: fn($: ?), elementSelector: fn($: ?), compareSelector?: fn(key: ?)) -> ?",
      "ToJSON": "fn(replacer?: fn(key: ?, value: ?), space?: number) -> string",
      "ToString": "fn(separator?: string, selector?: fn($: ?)) -> string",
      "Do": "fn(action: fn($: ?, i: number)) -> ?",
      "ForEach": "fn(action: fn($: T, i: number))",
      "Write": "fn(separator?: string, selector?: fn($: ?))",
      "WriteLine": "fn(selector?: fn($: ?))",
      "Force": "fn()",
      "Let": "fn(func: fn(e: ?)) -> ?",
      "Share": "fn() -> ?",
      "MemoizeAll": "fn() -> ?",
      "Catch": "fn(handler: fn(error: Error)) -> ?",
      "Finally": "fn(finallyAction: fn()) -> ?",
      "Trace": "fn(message?: string, selector?: fn($: ?)) -> ?"
    },
    "OrderedEnumerable": {
      "ThenBy": "fn(keySelector: fn($: T)) -> ?",
      "ThenByDescending": "fn(keySelector: fn($: T)) -> ?"
    },
    "Grouping": {
      "Key": "fn()"
    },
    "Lookup": {
      "Count": "fn() -> number",
      "Get": "fn(key: ?) -> ?",
      "Contains": "fn(key: ?) -> bool",
      "ToEnumerable": "fn() -> ?"
    },
    "Dictionary": {
      "Add": "fn(key: ?, value: ?)",
      "Get": "fn(key: ?) -> ?",
      "Set": "fn(key: ?, value: ?) -> bool",
      "Contains": "fn(key: ?) -> bool",
      "Clear": "fn()",
      "Remove": "fn(key: ?)",
      "Count": "fn() -> number",
      "ToEnumerable": "fn() -> ?"
    },
    "KeyValuePair": {
      "Key": "TKey",
      "Value": "TValue"
    }
  },
  "Enumerable": "linq.EnumerableStatic",
  "!name": "linq"
}
