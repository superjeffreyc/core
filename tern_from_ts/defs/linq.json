{
  "linqjs": {
    "IEnumerator": {
      "current": "fn() -> ?",
      "moveNext": "fn() -> bool",
      "dispose": "fn()"
    },
    "EnumerableStatic": {
      "Utils": {
        "createLambda": "fn(expression: ?) -> fn(params: [?])",
        "createEnumerable": "fn(getEnumerator: fn()) -> Enumerable",
        "createEnumerator": "fn(initialize: fn(), tryGetNext: fn(), dispose: fn()) -> IEnumerator",
        "extendTo": "fn(type: ?)"
      },
      "choice": "fn(params: [?]) -> Enumerable",
      "cycle": "fn(params: [?]) -> Enumerable",
      "empty": "fn() -> Enumerable",
      "from": "fn() -> Enumerable",
      "make": "fn(element: ?) -> Enumerable",
      "matches": "fn(input: string, pattern: RegExp) -> Enumerable",
      "range": "fn(start: number, count: number, step?: number) -> Enumerable",
      "rangeDown": "fn(start: number, count: number, step?: number) -> Enumerable",
      "rangeTo": "fn(start: number, to: number, step?: number) -> Enumerable",
      "repeat": "fn(element: ?, count?: number) -> Enumerable",
      "repeatWithFinalize": "fn(initializer: fn(), finalizer: fn(element: ?)) -> Enumerable",
      "generate": "fn(func: fn(), count?: number) -> Enumerable",
      "toInfinity": "fn(start?: number, step?: number) -> Enumerable",
      "toNegativeInfinity": "fn(start?: number, step?: number) -> Enumerable",
      "unfold": "fn(seed: ?, func: fn(value: ?)) -> Enumerable",
      "defer": "fn(enumerableFactory: fn()) -> Enumerable"
    },
    "Enumerable": {
      "getEnumerator": "fn() -> IEnumerator",
      "traverseBreadthFirst": "fn(func: fn(element: ?), resultSelector?: fn(element: ?, nestLevel: number)) -> Enumerable",
      "traverseDepthFirst": "fn(func: fn(element: ?), resultSelector?: fn(element: ?, nestLevel: number)) -> Enumerable",
      "flatten": "fn() -> Enumerable",
      "pairwise": "fn(selector: fn(prev: ?, current: ?)) -> Enumerable",
      "scan": "fn(func: fn(prev: ?, current: ?)) -> Enumerable",
      "select": "fn(selector: fn(element: ?, index: number)) -> Enumerable",
      "selectMany": "fn(collectionSelector: fn(element: ?, index: number), resultSelector?: fn(outer: ?, inner: ?)) -> Enumerable",
      "where": "fn(predicate: fn(element: ?, index: number)) -> Enumerable",
      "choose": "fn(selector: fn(element: ?, index: number)) -> Enumerable",
      "ofType": "fn(type: ?) -> Enumerable",
      "zip": "fn(second: [?], resultSelector: fn(first: ?, second: ?, index: number)) -> Enumerable",
      "merge": "fn(second: [?], resultSelector: fn(first: ?, second: ?, index: number)) -> Enumerable",
      "join": "fn(inner: Enumerable, outerKeySelector: fn(outer: ?), innerKeySelector: fn(inner: ?), resultSelector: fn(outer: ?, inner: ?), compareSelector?: fn(obj: ?)) -> Enumerable",
      "groupJoin": "fn(inner: Enumerable, outerKeySelector: fn(outer: ?), innerKeySelector: fn(inner: ?), resultSelector: fn(outer: ?, inner: ?), compareSelector?: fn(obj: ?)) -> Enumerable",
      "all": "fn(predicate: fn(element: ?)) -> bool",
      "any": "fn(predicate?: fn(element: ?)) -> bool",
      "isEmpty": "fn() -> bool",
      "concat": "fn(sequences: [?]) -> Enumerable",
      "insert": "fn(index: number, second: [?]) -> Enumerable",
      "alternate": "fn(alternateValue: ?) -> Enumerable",
      "contains": "fn(value: ?, compareSelector: fn(element: ?)) -> Enumerable",
      "defaultIfEmpty": "fn(defaultValue?: ?) -> Enumerable",
      "distinct": "fn(compareSelector?: fn(element: ?)) -> Enumerable",
      "distinctUntilChanged": "fn(compareSelector: fn(element: ?)) -> Enumerable",
      "except": "fn(second: [?], compareSelector?: fn(element: ?)) -> Enumerable",
      "intersect": "fn(second: [?], compareSelector?: fn(element: ?)) -> Enumerable",
      "sequenceEqual": "fn(second: [?], compareSelector?: fn(element: ?)) -> Enumerable",
      "union": "fn(second: [?], compareSelector?: fn(element: ?)) -> Enumerable",
      "orderBy": "fn(keySelector: fn(element: ?)) -> OrderedEnumerable",
      "orderByDescending": "fn(keySelector: fn(element: ?)) -> OrderedEnumerable",
      "reverse": "fn() -> Enumerable",
      "shuffle": "fn() -> Enumerable",
      "weightedSample": "fn(weightSelector: fn(element: ?)) -> Enumerable",
      "groupBy": "fn(keySelector: fn(element: ?), elementSelector?: fn(element: ?), resultSelector?: fn(key: ?, element: ?), compareSelector?: fn(element: ?)) -> Enumerable",
      "partitionBy": "fn(keySelector: fn(element: ?), elementSelector?: fn(element: ?), resultSelector?: fn(key: ?, element: ?), compareSelector?: fn(element: ?)) -> Enumerable",
      "buffer": "fn(count: number) -> Enumerable",
      "aggregate": "fn(func: fn(prev: ?, current: ?)) -> ?",
      "average": "fn(selector?: fn(element: ?)) -> number",
      "count": "fn(predicate?: fn(element: ?, index: number)) -> number",
      "max": "fn(selector?: fn(element: ?)) -> number",
      "min": "fn(selector?: fn(element: ?)) -> number",
      "maxBy": "fn(keySelector: fn(element: ?)) -> ?",
      "minBy": "fn(keySelector: fn(element: ?)) -> ?",
      "sum": "fn(selector?: fn(element: ?)) -> number",
      "elementAt": "fn(index: number) -> ?",
      "elementAtOrDefault": "fn(index: number, defaultValue?: ?) -> ?",
      "first": "fn(predicate?: fn(element: ?, index: number)) -> ?",
      "firstOrDefault": "fn(predicate?: fn(element: ?, index: number), defaultValue?: ?) -> ?",
      "last": "fn(predicate?: fn(element: ?, index: number)) -> ?",
      "lastOrDefault": "fn(predicate?: fn(element: ?, index: number), defaultValue?: ?) -> ?",
      "single": "fn(predicate?: fn(element: ?, index: number)) -> ?",
      "singleOrDefault": "fn(predicate?: fn(element: ?, index: number), defaultValue?: ?) -> ?",
      "skip": "fn(count: number) -> Enumerable",
      "skipWhile": "fn(predicate: fn(element: ?, index: number)) -> Enumerable",
      "take": "fn(count: number) -> Enumerable",
      "takeWhile": "fn(predicate: fn(element: ?, index: number)) -> Enumerable",
      "takeExceptLast": "fn(count?: number) -> Enumerable",
      "takeFromLast": "fn(count: number) -> Enumerable",
      "indexOf": "fn(item: ?) -> number",
      "lastIndexOf": "fn(item: ?) -> number",
      "asEnumerable": "fn() -> Enumerable",
      "toArray": "fn() -> [?]",
      "toLookup": "fn(keySelector: fn(element: ?), elementSelector?: fn(element: ?), compareSelector?: fn(element: ?)) -> Lookup",
      "toObject": "fn(keySelector: fn(element: ?), elementSelector?: fn(element: ?)) -> Object",
      "toDictionary": "fn(keySelector: fn(element: ?), elementSelector?: fn(element: ?), compareSelector?: fn(element: ?)) -> Dictionary",
      "toJSONString": "fn(replacer: fn(key: string, value: ?)) -> string",
      "toJoinedString": "fn(separator?: string, selector?: fn(element: ?, index: number)) -> string",
      "doAction": "fn(action: fn(element: ?, index: number)) -> Enumerable",
      "forEach": "fn(action: fn(element: ?, index: number))",
      "write": "fn(separator?: string, selector?: fn(element: ?))",
      "writeLine": "fn(selector?: fn(element: ?))",
      "force": "fn()",
      "letBind": "fn(func: fn(source: Enumerable)) -> Enumerable",
      "share": "fn() -> DisposableEnumerable",
      "memoize": "fn() -> DisposableEnumerable",
      "catchError": "fn(handler: fn(exception: ?)) -> Enumerable",
      "finallyAction": "fn(finallyAction: fn()) -> Enumerable",
      "log": "fn(selector?: fn(element: ?)) -> Enumerable",
      "trace": "fn(message?: string, selector?: fn(element: ?)) -> Enumerable"
    },
    "OrderedEnumerable": {
      "createOrderedEnumerable": "fn(keySelector: fn(element: ?), descending: bool) -> OrderedEnumerable",
      "thenBy": "fn(keySelector: fn(element: ?)) -> OrderedEnumerable",
      "thenByDescending": "fn(keySelector: fn(element: ?)) -> OrderedEnumerable"
    },
    "DisposableEnumerable": {
      "dispose": "fn()"
    },
    "Dictionary": {
      "add": "fn(key: ?, value: ?)",
      "get": "fn(key: ?) -> ?",
      "set": "fn(key: ?, value: ?) -> bool",
      "contains": "fn(key: ?) -> bool",
      "clear": "fn()",
      "remove": "fn(key: ?)",
      "count": "fn() -> number",
      "toEnumerable": "fn() -> Enumerable"
    },
    "Lookup": {
      "count": "fn() -> number",
      "get": "fn(key: ?) -> Enumerable",
      "contains": "fn(key: ?) -> bool",
      "toEnumerable": "fn() -> Enumerable"
    },
    "Grouping": {
      "key": "fn() -> ?"
    }
  },
  "Enumerable": "linqjs.EnumerableStatic",
  "!name": "linq.3.0.3-Beta4"
}
